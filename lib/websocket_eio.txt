(* open Eio.Std

(* Eio-based WebSocket client using the core websocket library *)
module WebSocket_Client = struct
  type t = {
    flow : Eio.Flow.two_way_ty Eio.Resource.t;
    mutable state : [ `Connecting | `Connected | `Closed ];
    uri : Uri.t;
    headers : (string * string) list;
    mutex : Eio.Mutex.t;
  }

  type frame = Websocket.Frame.t

  exception WebSocket_error of string
  exception Connection_closed

  let create ~uri ?(headers = []) () =
    {
      flow = (Obj.magic () : Eio.Flow.two_way_ty Eio.Resource.t);
      state = `Connecting;
      uri;
      headers;
      mutex = Eio.Mutex.create ();
    }

  let connect t ~net ~sw =
    Eio.Mutex.use_rw t.mutex (fun () ->
        if t.state = `Connected then Ok t
        else
          try
            let host = Uri.host_with_default t.uri in
            let port =
              match Uri.port t.uri with
              | Some p -> p
              | None -> if Uri.scheme t.uri = Some "wss" then 443 else 80
            in

            let addr = `Tcp (Eio.Net.Ipaddr.V4.loopback, port) in
            let socket = Eio.Net.connect ~sw net addr in

            (* Perform WebSocket handshake *)
            let key =
              Base64.encode_string (Bytes.to_string (Bytes.create 16))
            in
            let headers =
              [
                ("Host", host);
                ("Upgrade", "websocket");
                ("Connection", "Upgrade");
                ("Sec-WebSocket-Key", key);
                ("Sec-WebSocket-Version", "13");
              ]
              @ t.headers
            in

            let request_line =
              Printf.sprintf "GET %s HTTP/1.1\r\n" (Uri.path_and_query t.uri)
            in
            let header_lines =
              List.map (fun (k, v) -> k ^ ": " ^ v ^ "\r\n") headers
            in
            let request =
              request_line ^ String.concat "" header_lines ^ "\r\n"
            in

            Eio.Flow.copy_string request socket;

            (* Read and parse response *)
            let response_buf = Buffer.create 1024 in
            let buf = Bytes.create 1024 in
            let read_response () =
              let response = Eio.Buf_read.of_flow socket ~max_size:1024 in
              let line = Eio.Buf_read.line response in
              let lines = [ line ] in
              let rec read_lines acc =
                match Eio.Buf_read.line response with
                | line when String.trim line = "" ->
                    String.concat "\n" (List.rev acc)
                | line -> read_lines (line :: acc)
                | exception End_of_file -> String.concat "\n" (List.rev acc)
              in
              read_lines lines
            in

            let response = read_response () in
            let lines = String.split_on_char '\n' response in

            (* Validate WebSocket response *)
            match lines with
            | status_line :: _ when String.contains status_line "101" ->
                (* WebSocket handshake successful *)
                t.flow <- socket;
                t.state <- `Connected;
                Ok t
            | _ ->
                t.state <- `Closed;
                Error (WebSocket_error "WebSocket handshake failed")
          with exn ->
            t.state <- `Closed;
            Error (WebSocket_error (Printexc.to_string exn)))

  let send_frame t frame =
    Eio.Mutex.use_rw t.mutex (fun () ->
        if t.state <> `Connected then raise Connection_closed
        else
          try
            let frame_bytes = Websocket.Frame.to_bytes frame in
            Eio.Flow.copy_string (Bytes.to_string frame_bytes) t.flow
          with exn -> raise (WebSocket_error (Printexc.to_string exn)))

  let send_text t text =
    let frame =
      Websocket.Frame.create ~opcode:Websocket.Frame.Opcode.Text ~content:text
        ()
    in
    send_frame t frame

  let send_binary t data =
    let frame =
      Websocket.Frame.create ~opcode:Websocket.Frame.Opcode.Binary ~content:data
        ()
    in
    send_frame t frame

  let recv_frame t =
    Eio.Mutex.use_rw t.mutex (fun () ->
        if t.state <> `Connected then raise Connection_closed
        else
          try
            let buf_read = Eio.Buf_read.of_flow t.flow ~max_size:4096 in
            let data = Eio.Buf_read.take_all buf_read in
            Websocket.Frame.of_bytes (Bytes.of_string data)
          with exn -> raise (WebSocket_error (Printexc.to_string exn)))

  let close t ?(code = 1000) () =
    Eio.Mutex.use_rw t.mutex (fun () ->
        if t.state = `Connected then
          try
            let close_frame =
              Websocket.Frame.create ~opcode:Websocket.Frame.Opcode.Close
                ~content:(string_of_int code) ()
            in
            send_frame t close_frame;
            t.state <- `Closed;
            Eio.Flow.close t.flow
          with _ -> t.state <- `Closed)

  let is_connected t = t.state = `Connected
end *)
